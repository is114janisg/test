<!DOCTYPE html>
<html lang="no-NB">
<head>
    <meta charset="utf-8">
    <title>IS-114 Programmering SVG</title>
    <link href='https://fonts.googleapis.com/css?family=IBM Plex Serif' rel='stylesheet'>
    <style>
      body {
        background-color: #00203FFF; /* #240d20 */
        color: #ADEFD1; /* #fbdcc4 074989 #ADEFD1FF 004588*/
        font-family: 'IBM Plex Serif', 'Georgia', Times, serif;
      }
      .maincolumn {
        width: 38em;
        margin-right: -40em;
        margin-left: 15em;
        line-height: 1.6em;
      }
      pre {
        background-color: #cfd1a7;
        overflow: auto;
        font-family: 'Monaco', monospace;
        padding: 0 1em;
        font-size: 0.9em;
      }
      code {
        font-family: Monaco, monospace;
        line-height: 100%;
        color: #636262;
        padding: 0.2em;
        letter-spacing: -0.05em;
        word-break: normal;
        /border-radius: 5px;/
      }
      .refelem, .refcolumn, .refcontent {
        background-color: #002F5D;
        color: #C57500; /* #eeeeee */
        border-color: black;
        font-family: 'IBM Plex Serif';
      }
      .refpara, .refelem {
        position: relative;
        float: right;
        left: 2em;
        height: 0em;
        width: 13em;
        margin: 0em -13em 0em 0em;
      }
      .refcolumn {
        background-color: #002F5D; /* #F5F5DC */
        display: block;
        position: relative;
        width: 13em;
        font-size: 85%;
        border: 0.5em solid #002F5D;
        margin: 0 0 0 0;
        white-space: normal;
      }
      .refcontent {
        margin: 0 0 0 0;
      }
    </style>
</head>
<body>
  <div class="maincolumn">
    <h1>Systemutvikling</h1>
    <p>Modellen med hovedfaser ANALYSE, DESIGN og IMPLEMENTERING (systemutviklingssyklus) er langt ifra en presis beskrivelse av virkeligheten. Et spørsmål kan alltid stilles, - hvis praktisk erfaring indikerer at modellen ikke samsvarer med virkeligheten, skal man forkaste modellen (og eventuelt designe en ny modell), eller, skal man forsøke å "presse inn" de nye erfaringene i den eksisterende modellen? Den såkalte agile systemutviklingsmetode er et eksempel på det siste, dvs. modellen justeres for å beskrive mer brukerinnvolvering i alle fasene av systemutviklingssyklus.</p>
    <p>Filosofen Mario Bunge tenker at enhver menneskelig aktivitet, rettet mot et mål, kan beskrives (modelleres!) med følgende faser i en "løs" sekvens OBSERVER --> TENK --> ANALYSER --> MODELLER --> DESIGNE --> TESTE. Med andre ord <i>"lære først, handle etterpå"</i>. Hvis vi antar at målet med programmering er å bidra til at homo sapiens kan gjennomføre aktiviteter (vanligvis for profitt, effektivitet eller for "å gjøre verden til et bedre sted"), må en utvikler besitte kunnskap om både vitenskap og teknologi. Alle praktiske situasjoner (samarbeid, for eksempel) kan være en scene for teknologiutvikling (verktøy for å samle inn data om gruppemedlemmer). Enhver "effektiv" teknologi kan være basert på eller bekreftet av en eller flere vitenskaper (psykologi, fysikk, datavitenskap osv.) og på denne måten endre praksis. Teknologi er også verdibasert, mens vitenskap bør være tilnærmet verdifri (utopi?). Teknologer (utviklere?) møter moralske problemer, som ikke er relevante for vitenskap (grunnforskning). Alt dette gjør at utvikler er plassert i en kompleks og kaotisk verden, hvor det finnes ubegrensett antall av løsninger for et problem. En viktig egenskap da kan være å "finne ut" om hvordan ting og systemer funksjonerer og en generell tilnærming kan være fokus på testing.
    </p>
    <p>Ofte gjør utvikleren kun sjekking av sin kode. <i>Sjekking</i> er en prosess for å bekrefte, verifisere eller validere noe man allerede vet. <i>Testing</i> derimot er en prosess for å utforske, oppdage, etterforske og lære. Det er ingen konkrete forventinger til resultatet i testing (for eksempel, teste skadeomfanget på bil X av merke A når den treffer en vegg frontalt med en fart på 100 km/t). I praksis blander man vanligvis sjekking og testing.</p>
    <p>Ofte er testing fremstilt som EN fase i en modell. Men kunne man også se på testing som grunnleggende metode for utvikling av systemer generelt? Finnes det "testing" i hvert steg av prosessen for å lage datasystemer?</p>


    <h2>Testing</h2>
    <p>Det finnes mye litteratur om testing (se for eksempel (Beck, 2014)), men det kan være en utfordring å finne noe, som umiddlebart passer i en konkret situasjon. Forskjellige mentale modeller har forskjellige navn på elementer i testing. Integrasjonstest, systemtest, enhetstest, regresjonstest osv. Begrepene er upresise og brukes i forskjellige kontekster med forskjellige meninger. Med andre ord, testing (og dermed systemutvikling) er i utgangspunktet en kreativ prosess. Men finnes det noen mønster, som vi kan dra nytte av?</p>

    <h3>Mønstre for testing</h3>
    <p>La oss se på noen grunnleggende spørsmål:</p>
    <ul>
      <li>Hva mener vi med testing? (delvis besvart tidligere, men viktig å betrakte konteksten)</li>
      <li>Når tester vi? (i forhold til noen faser i vår mentale modell; hvordan er testing annerledes i forhold til noe annet? vi skal forsøke oss på "vi tester først")</li>
      <li>Hvordan velger vi hvilken logikk som skal testes?</li>
      <li>Hvordan velger vi hvilke data vi skal teste?</li>
    </ul>
    <p>Hvorfor føles det annerledes å utføre test automatisk, enn det å trykke noen knapper og se resultater på en skjerm? Når en utvikler "sjekker" intenst i brukergrensesnitt, og ting ikke fungerer som forventet, så øker stressnivået. Dette stressnivået kan ta fokuset bort fra testing. Et vanlig uttrykk er "vi har ikke tid å teste, bare publiser/deployer det". Uten automatiske tester, vil man ikke kunne oppdage nye feil, som man potensielt introduserer med ny kode. Med automatiske tester, kan utvikler i større grad selv velge sitt stressnivå.</p>
    <p>Skal kjøring (bruker dette ordet som oversettelse for den engelske "run") av tester påvirke hverandre? Ikke i det hele tatt. Hvordan kan en få det til? Designe tester så korte og "raske" som mulig. Og, tester skal ikke være avhengig av hverandre, dvs. de skal være ISOLERTE. Ligner dette kanskje på WBS (Work Breakdown Structure) eller det å lage avgrensninger, dvs. designe ditt system?</p>
    <p>Skriv en liste av tester før du starter. Hva ønsker vi å oppnå med programmering i dag? Hvilke refaktoreringer trenger vi å gjøre? Holde tester en endring unna tilfredsstilt/passert/godkjent. </p>
    <p>Teste først, dvs. før du skriver kode, som skal testes. Utviklerens mål er å drive funksjonalitet, men det er også viktig å tenke på design og kontrollere avgrensninger (en. scope).</p>
    <p>"assert" (hevde, påstå) først ("assert" sannhet og likhet, eventuelt usannhet og ulikhet). Kan hjelpe å besvare spørsmål som, hvor skal funksjonalitet høre til, skal vi modifisere eksisterende funksjon, skrive en ny funksjon, lage en ny type/klasse? Hva skal vi kalle "ting"? Hvordan skal vi sjekke for rett svar? Hva er rett svar? Hvilke andre tester impliserer vår test?</p>
    <p>Hva med testdata? Velg passelig antall med testkilder, hvis det skal være flere kilder i ditt system. Data bør være realistiske.</p>
    <p>Rødt mønster (relatert til rødt-grønt-refaktorering løkken): testen er rødt i utgangspunktet. Hvor hører operasjon hjemme? Hva er korrekt input? Hva er korrekt output gitt et konkret input? Input så liten som mulig. Hvilken test skal man starte med? Prøve å uttrykke/formulere alt i form av tester, - gitt Foo og Bar, blir svaret 452? Når vi har Foo og Bar som dette, så er er svaret 452 (eller eventuelt et line-element med en konkret syntaks). Hvis vi har Foo og Bar på en annen måte, blir svaret da 254? Tester for læring er viktig, spesielt i læringsssammenheng. Tester for læring dekker vanligvis testing av eksisterende moduler, biblioteker, klasser osv. (testDomApi). Nye ideer vil dukke opp i prosessen. Skriv disse ned. Og husk at det er viktig å komme seg bort fra noe man sliter for lenge med. Avbrekk kan være i forskjellige tidsperspektiv. Hvis du føler at du kommer ingen vei, kast all kode og starte på nytt!</p>
    <p></p>

    <p>For eksempel, i dag skal vi:</p>
    <ul>
      <li>Fortelling: ser en visualisering av data fra spørreskjema på skjermen, i vinduet til en nettleser og basert på SVG API for HTML 5 (data og visualisering må spesifiseres/velges).</li>
      <li>Forstå hvordan enkle funksjoner i SVG API i HTML 5 funksjonerer. Aktuelle tester, - legge verdien inn i DOM eller CSSOM og hente verdien ut ved hjelp av DOM API funksjoner (DOM treet er gitt og er et stabilt bibliotek/mekanisme)</li>
      <li>Vise en linje i en SVG element ved å bruke HTML kode (kan HTML testes automatisk?)</li>
      <li>Input så liten som mulig (line element i svg element: plotter = enPlotterFunksjon(input); assertEquals('<line>...', plotter.resultat);)</li>
      <li>testTransaksjonFullført (kan være assertTrue(leseren.erFerdig) og assertEquals(ønsket, innholdIResponsen))</li>
      <li>hvor kommer innholdResponsen fra? (leseren.Innhold)</li>
      <li>startServer, nyKanal, allokerMelding, skrivTilKanal, assertEquals(melding, avlesKanal)</li>
      <li>hva er leseren? det må ha en kilde (url?) og den må kunne avleses (fetch og then?)</li>
      <li>bruke realistiske data, men ikke nødvendigvis fra ekstern database (mock-data)</li>
      <li>test: beregne verdi som skal bestemme plassen av sirkelen på linjen (testBeregningAvPosisjon, trenger verdier av linjelengde, skalaen for verdien fra spørreundersøkelse, for eksempel maksimalverdien for begge) assertEquals(ønsket, returFraFunksjonenSomTestes)
      </li>
    </ul>

    <h3>GUI testing</h3>
    <p>Mest vanlig er manuell GUI testing, - skriv kode, utfør kode, sjekk grensesnitt. Her fokuserer vi på koding og ikke på brukeropplevelse. Foreløpig har vi ikke utviklet metoder for å teste brukeropplevelse kun programmatisk (les automatisk). Derfor viser vi brukere skjermen og spør hva de "føler" eller ber dem å gjøre konkrete oppgaver og observere hvordan de klarer det.</p>
    <p><ul>
      <li>GUI "typer": nettleser, mobile apper, skrivebordsapplikasjoner (GUI elementer uttrykkes i modeller på forskjellige måter, men det finnes noen likheter)</li>
      <li>Objekt - Strek - Piksel</li>
      <li>Beholdt og Umiddelbar (modus)
        <span class="refelem"><span class="refcolumn"><span class="refcontent">Beholdt: Påkallelser for å lage en strek er lagret (beholdt) og gjennomført når skjermen eller deler av skjermen tegnes på nytt (en. redraw).</span></span></span>
      </li>
        <li>INPUT (lokal eller ekstern fil, form) --> MIN JS FUNKSJON --> DOM, CSSOM, FETCH --> OUTPUT (piksler som kan oppfattes som en helhet; grafikk)
          <ul>
            <li>INPUT og MIN JS FUNSJON kan erstattes med et program som "driver/styrer" nettleserens VM og har tilgang til alle API-ene (DOM, CSSOM, FETCH osv.)</li>
          </ul>
        </li>
    </ul></p>

  <h3>Test-trekanten</h3>
  <p>I utgangspunktet er dette en ønsket representasjon av antall tester for de forskjellige "kategoriene" (desto bredere trekanten, jo flere tester). Men i praksis blir triangelet ofte snudd opp ned mens kategoriene beholder den samme rekkefølgen, dvs. at man gjør mest "intuitiv" UI-testing (vanligvis uten dokumentasjon) og dropper isolerte tester, som er relatert til egen system-modell. "Testing av diverse objekter" refererer her til testing av eksisterende biblioteker, moduler, funksjoner eller klasser (for eksempel, DOM API, som er implementert i de fleste brukbare nettlesere, eller <i>sukrede</i> funksjoner i JavaScript som "map", "forEach", "sort", "json" osv.)</p>

  <p><span><svg height="300" width="300" viewBox="0 0 300 300">
      <polygon points="140 20 270 270 10 270 140 20" stroke="gray" fill="transparent" stroke-width="2"/>
      <line x1="88" x2="192" y1="120" y2="120" stroke="gray" stroke-width="2"/>
      <line x1="47" x2="233" y1="200" y2="200" stroke="red" stroke-width="2"/>
      <text x="130" y="80"><tspan fill="orange">UI</tspan></text>
      <text x="115" y="100"><tspan fill="orange">testing</tspan></text>
      <text x="100" y="150"><tspan fill="orange">Testing av</tspan></text>
      <text x="80" y="170"><tspan fill="orange">diverse objekter</tspan></text>
      <text x="80" y="240"><tspan fill="orange">Isolerte tester</tspan></text>
		    Sorry, your browser does not support inline SVG.
	  </svg></span>
    <span>
      <svg height="300" width="300" viewBox="0 0 300 300">
          <polygon points="140 270 270 20 10 20 140 270" stroke="gray" fill="transparent" stroke-width="2"/>
          <line x1="88" x2="192" y1="172" y2="172" stroke="red" stroke-width="2"/>
          <line x1="47" x2="233" y1="93" y2="93" stroke="gray" stroke-width="2"/>
  <text x="55" y="15"><tspan fill="red">IKKE OPTIMAL MODELL</tspan></text>
          <text x="130" y="50"><tspan fill="orange">UI</tspan></text>
          <text x="115" y="70"><tspan fill="orange">testing</tspan></text>
          <text x="105" y="120"><tspan fill="orange">Testing av</tspan></text>
          <text x="75" y="140"><tspan fill="orange">diverse objekter</tspan></text>
          <text x="115" y="190"><tspan fill="orange">Isolerte</tspan></text>
  <text x="120" y="210"><tspan fill="orange">tester</tspan></text>
    		    Sorry, your browser does not support inline SVG.
    	  </svg>
    </span></p>
    <h2>Referanser</h2>
    <ul>
      <li>Beck, K. (2014). Test-driven development by example. Boston Addison-Wesley.</li>
      <li>KentBeck.com. (2018). Kentbeck.com.</li>
    </ul>
  </div>

</body>
</html>
